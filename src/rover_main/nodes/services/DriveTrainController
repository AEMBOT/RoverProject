#!/usr/bin/python3

import rospy

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse
from rover_main.srv import I2C_Service

# Address that the arduino is located at on the I2C bus
CONTROL_ARDUINO_ADDRESS = 0x08

# Global instance of the I2C Service object
I2C_SERVICE = None

# Store the values from the last motor speed request
LAST_MOTOR_SPEEDS = []

def on_service_contact(data):
    global LAST_MOTOR_SPEEDS
    motor_speeds = data.motor_speeds
    wheel_angles = data.wheel_angles

    # Loop through the motor speeds and prepare the data to be sent to the arduino
    for value, i in enumerate(motor_speeds):
        motor_speeds[i] = unit_range_to_controller(value)

    # Check to see if the motor values have actually changed
    if motor_speeds != LAST_MOTOR_SPEEDS:
        try:
            I2C_SERVICE(i2c_data=bytes(motor_speeds), register_id=0, device_address=CONTROL_ARDUINO_ADDRESS)
            return DriveTrainServiceResponse("Request Executed Successfully")
        except Exception as e:
            return DriveTrainServiceResponse(f"I2C Exception Occurred: {e}")

    # Copy the current motor speed variable to the last
    LAST_MOTOR_SPEEDS = motor_speeds.copy()

def init_node():

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainController", anonymous=True)

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Wait for the I2C Service to be up
    rospy.wait_for_service("I2C_Service")

    # Create a persistent connection to the I2C Service
    global I2C_SERVICE
    I2C_SERVICE = rospy.ServiceProxy("I2C_Service", service_class=I2C_Service, persistent=True)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()} awaiting instruction...")

    # Setup handlers
    rospy.spin()

def unit_range_to_controller(value):
    """Convert from 0 - 1 to 0 - 127 with 64 in the middle to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

if __name__ == "__main__":
    init_node()