#!/usr/bin/python3

import rospy
import enum

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse
from rover_main.srv import I2C_Service

class I2CRegisterID(enum.Enum):
    """Maps variable names to the corresponding register ids"""
    DriveMotors = 0
    TurnServos = 1

# Address that the arduino is located at on the I2C bus
CONTROL_ARDUINO_ADDRESS = 0x08

# Global instance of the I2C Service object
I2C_SERVICE = None

# Store the values from the last motor speed request
LAST_MOTOR_SPEEDS = []

def on_service_contact(data):
    global LAST_MOTOR_SPEEDS
    motor_speeds = list(data.motor_speeds)
    wheel_angles = list(data.wheel_angles)

    # Loop through the motor speeds and prepare the data to be sent to the arduino
    for i, value in enumerate(motor_speeds):
        motor_speeds[i] = unit_range_to_controller(value)

    # Check to see if the motor values have actually changed
    if motor_speeds != LAST_MOTOR_SPEEDS:
        try:
            I2C_SERVICE(i2c_data=bytes(motor_speeds), register_id=I2CRegisterID.DriveMotors, device_address=CONTROL_ARDUINO_ADDRESS)
            return DriveTrainServiceResponse("Request Executed Successfully")
        except Exception as e:
            return DriveTrainServiceResponse(f"I2C Exception Occurred: {e}")

    # Copy the current motor speed variable to the last
    LAST_MOTOR_SPEEDS = motor_speeds.copy()

def init_node():

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainController", anonymous=True)

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Wait for the I2C Service to be up
    rospy.wait_for_service("I2C_Service")

    # Create a persistent connection to the I2C Service
    global I2C_SERVICE
    I2C_SERVICE = rospy.ServiceProxy("I2C_Service", service_class=I2C_Service, persistent=True)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()} awaiting instruction...")

    # Setup handlers
    rospy.spin()

def unit_range_to_controller(value):
    """Convert from -1 to 1 to 0 to 127 with 64 in the middle to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

if __name__ == "__main__":
    init_node()