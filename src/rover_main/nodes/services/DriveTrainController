#!/usr/bin/python3

import rospy
import enum

from roboclaw import Roboclaw

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse
from rover_main.srv import I2C_Service

class I2CRegisterID(enum.Enum):
    """Maps variable names to the corresponding register ids"""
    DriveTrain = 222

# Address that the arduino is located at on the I2C bus
CONTROL_ARDUINO_ADDRESS = 0x08

# Roboclaw device set to talk over serial, ttyS0 corresponds to GPIO 14 & 15 or standard TX and RX on the Rpi
roboclaw = Roboclaw("/dev/ttyS0", 115200)

# Global instance of the I2C Service object
I2C_SERVICE = None

true_motor_inputs = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64]

# Addresses for packet serial to identify the driver controllers
drive_controller_1 = 0x80
drive_controller_2 = 0x81
drive_controller_3 = 0x82

# Addresses for the steering controllers
steering_controller_4 = 0x83
steering_controller_5 = 0x84

# Store the values from the last motor speed request
LAST_MOTOR_INPUTS = []

def on_service_contact(data):
    global LAST_MOTOR_INPUTS, roboclaw

    # List of the forward vector and turn vectors
    motor_inputs = [data.motor_speeds]
    wheel_angles = [data.wheel_angles]

    # Combine vectors into one list
    motor_inputs.extend(wheel_angles)

    # Loop through the motor speeds and prepare the data to be sent to the arduino
    for i, value in enumerate(motor_inputs):

        # Convert the 2 joystick values into a full array of motor inputs
        if i == 0:
            for c in range(6):
                true_motor_inputs[c] = unit_range_to_controller(value)
        else:
            for c in range(4):
                c+=6
                true_motor_inputs[c] = unit_range_to_controller(value)

    # Check to see if the motor values have actually changed
    if true_motor_inputs != LAST_MOTOR_INPUTS:
        
        try:
            # Commanding all the drive train controllers
            roboclaw.ForwardBackwardM1(drive_controller_1, true_motor_inputs[0])
            roboclaw.ForwardBackwardM2(drive_controller_1, true_motor_inputs[1])
            roboclaw.ForwardBackwardM1(drive_controller_2, true_motor_inputs[2])
            roboclaw.ForwardBackwardM2(drive_controller_2, true_motor_inputs[3])
            roboclaw.ForwardBackwardM1(drive_controller_3, true_motor_inputs[4])
            roboclaw.ForwardBackwardM2(drive_controller_3, true_motor_inputs[5])

            # Copy the current motor speed variable to the last
            LAST_MOTOR_INPUTS = true_motor_inputs.copy()

            return DriveTrainServiceResponse("Request Executed Successfully")

        except Exception as e:

            # Copy the current motor speed variable to the last
            LAST_MOTOR_INPUTS = true_motor_inputs.copy()

            return DriveTrainServiceResponse(f"The DriveTrainController encountered an exception: {e}")

    

def init_node():
    global roboclaw
    roboclaw.Open()

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainControllerNode")

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Add some log information for the boot proccess
    rospy.loginfo(f"{rospy.get_name()}: waiting for the I2C_service")

    # Wait for the I2C Service to be up
    rospy.wait_for_service("I2C_Service")
    
    # Create a persistent connection to the I2C Service
    global I2C_SERVICE
    I2C_SERVICE = rospy.ServiceProxy("I2C_Service", service_class=I2C_Service, persistent=True)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()}: awaiting instruction...")

    # Setup handlers
    rospy.spin()

def unit_range_to_controller(value):
    """Convert from -1 to 1 to 0 to 127 with 64 in the middle to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

if __name__ == "__main__":
    init_node()
