#!/usr/bin/python3

import rospy

from enum import Enum

from roboclaw import Roboclaw

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse

# Setup a roboclaw object to connect to devices on the standard TX/RX serial bus on the Pi with a baudrate of 115200
roboclaw = Roboclaw("/dev/ttyS0", 115200)

"""
Hex to ID mappings for controllers
    Drive Motors
        0x80 = 128
        0x81 = 129
        0x82 = 130

    Steering Motors
        0x83 = 131
        0x84 = 132
"""
drive_controller_1 = 0x80
drive_controller_2 = 0x81
drive_controller_3 = 0x82

steering_controller_4 = 0x83
steering_controller_5 = 0x84

# Store the values from the last motor speed request
LAST_DRIVE_SPEED = 0.0
LAST_ANGLE_INPUT = 0.0

def on_service_contact(data):
    global LAST_DRIVE_SPEED, LAST_ANGLE_INPUT, roboclaw

    # List of the forward vector and turn vectors
    drive_speed = data.motor_speeds
    wheel_angle_input = data.wheel_angles

    if drive_speed != LAST_DRIVE_SPEED:
        # Drive Motors

        # MCP 1
        roboclaw.ForwardBackwardM1(drive_controller_1, drive_speed)
        roboclaw.ForwardBackwardM2(drive_controller_1, drive_speed)
        
        # MCP 2
        roboclaw.ForwardBackwardM1(drive_controller_2, drive_speed)
        roboclaw.ForwardBackwardM2(drive_controller_2, drive_speed)

        # MCP 3
        roboclaw.ForwardBackwardM1(drive_controller_3, drive_speed)
        roboclaw.ForwardBackwardM2(drive_controller_3, drive_speed)

    if wheel_angle_input != LAST_ANGLE_INPUT:
        # Steering Motors

        # Roboclaw 1
        roboclaw.ForwardBackwardM1(steering_controller_4, calculate_wheel_angle(wheel_angle_input, WheelPosition.FRONT_LEFT))
        roboclaw.ForwardBackwardM2(steering_controller_4, calculate_wheel_angle(wheel_angle_input, WheelPosition.FRONT_RIGHT))

        # Roboclaw 2
        roboclaw.ForwardBackwardM1(steering_controller_5, calculate_wheel_angle(wheel_angle_input, WheelPosition.BACK_LEFT))
        roboclaw.ForwardBackwardM2(steering_controller_5, calculate_wheel_angle(wheel_angle_input, WheelPosition.BACK_RIGHT))

    LAST_ANGLE_INPUT = wheel_angle_input
    LAST_DRIVE_SPEED = drive_speed

    return DriveTrainServiceResponse("Request Executed Successfully")

def init_node():
    global roboclaw

    roboclaw.Open()

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainControllerNode")

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()}: awaiting instruction...")

    # Setup handlers
    rospy.spin()

def unit_range_to_controller(value):
    """Convert from -1 to 1 to 0 to 127 with 64 in the middle to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

def calculate_wheel_angle(value, wheelLocation):
    selected_wheel = wheelLocation.value
    return input

if __name__ == "__main__":
    init_node()

class WheelPosition(Enum):
    """Enum to track which wheel we are calculating the angle for"""
    FRONT_LEFT = 0
    FRONT_RIGHT = 1
    BACK_LEFT = 2
    BACK_RIGHT = 3