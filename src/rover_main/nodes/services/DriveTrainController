#!/usr/bin/python3

import rospy

from enum import Enum

from roboclaw import Roboclaw
import controller_math

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse

# Setup a roboclaw object to connect to devices on the standard TX/RX serial bus on the Pi with a baudrate of 115200
roboclaw = Roboclaw("/dev/ttyS0", 115200)

"""
Hex to ID mappings for controllers
    Drive Motors
        0x80 = 128
        0x81 = 129
        0x82 = 130

    Steering Motors
        0x83 = 131
        0x84 = 132
"""
drive_controller_1 = 0x80
drive_controller_2 = 0x81
drive_controller_3 = 0x82

# Addresses for the steering controllers
steering_controller_4 = 0x83
steering_controller_5 = 0x84

# Store the values from the last motor speed request
LAST_DRIVE_SPEED = 0.0
LAST_ANGLE_INPUT = 0.0

def on_service_contact(data):
    global LAST_DRIVE_SPEED, LAST_ANGLE_INPUT, roboclaw

    # List of the forward vector and turn vectors
    drive_speed = data.motor_speeds
    wheel_angle_input = data.wheel_angles

    if drive_speed != LAST_DRIVE_SPEED:
        # Drive Motors

        # MCP 1
        roboclaw.ForwardBackwardM1(drive_controller_1, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.FRONT_LEFT))
        roboclaw.ForwardBackwardM2(drive_controller_1, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.FRONT_RIGHT))
        
        # MCP 2
        roboclaw.ForwardBackwardM1(drive_controller_2, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.MIDDLE_LEFT))
        roboclaw.ForwardBackwardM2(drive_controller_2, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.MIDDLE_RIGHT))

        # MCP 3
        roboclaw.ForwardBackwardM1(drive_controller_3, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.BACK_LEFT))
        roboclaw.ForwardBackwardM2(drive_controller_3, controller_math.getNormalizedWheelSpeed(drive_speed, wheel_angle_input, WheelPosition.BACK_RIGHT))

    if wheel_angle_input != LAST_ANGLE_INPUT:
        # Steering Motors

        # Roboclaw 1
        roboclaw.ForwardBackwardM1(steering_controller_4, calculate_wheel_angle(wheel_angle_input, WheelPosition.FRONT_LEFT))
        roboclaw.ForwardBackwardM2(steering_controller_4, calculate_wheel_angle(wheel_angle_input, WheelPosition.FRONT_RIGHT))

        # Roboclaw 2
        roboclaw.ForwardBackwardM1(steering_controller_5, calculate_wheel_angle(wheel_angle_input, WheelPosition.BACK_LEFT))
        roboclaw.ForwardBackwardM2(steering_controller_5, calculate_wheel_angle(wheel_angle_input, WheelPosition.BACK_RIGHT))

    LAST_ANGLE_INPUT = wheel_angle_input
    LAST_DRIVE_SPEED = drive_speed

    return DriveTrainServiceResponse("Request Executed Successfully")

def init_node():
    global roboclaw

    roboclaw.Open()

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainControllerNode")

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()}: awaiting instruction...")

    # Setup handlers
    rospy.spin()



def calculate_wheel_angle(value, wheelLocation):
    selected_wheel = wheelLocation.value

    # Remap the controller inputs to the turnRadius inputs, and update the 
    turnRadius = controller_math.remapBounds(0, 1, 1, 10.4645, 1-abs(value))
    controller_math.updateCircleRadius(turnRadius)

    # Print out the angle for the given wheel
    print(f"{wheelLocation.name} : {controller_math.getWheelAngle(selected_wheel)}")
    return value

if __name__ == "__main__":
    init_node()

class WheelPosition(Enum):
    """Enum to track which wheel we are calculating the angle for"""
    FRONT_LEFT = 0
    FRONT_RIGHT = 1
    BACK_LEFT = 2
    BACK_RIGHT = 3
    MIDDLE_RIGHT = 4
    MIDDLE_LEFT = 5