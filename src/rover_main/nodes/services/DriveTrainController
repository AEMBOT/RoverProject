#!/usr/bin/python3

import rospy
import enum

from rover_main.srv import DriveTrainService, DriveTrainServiceResponse
from rover_main.srv import I2C_Service

class I2CRegisterID(enum.Enum):
    """Maps variable names to the corresponding register ids"""
    DriveTrain = 0
    SteeringMotors = 1

# Address that the arduino is located at on the I2C bus
CONTROL_ARDUINO_ADDRESS = 0x08

# Global instance of the I2C Service object
I2C_SERVICE = None

true_motor_inputs = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64]

# Store the values from the last motor speed request
LAST_MOTOR_INPUTS = []

def on_service_contact(data):
    global LAST_MOTOR_INPUTS, LAST_WHEEL_ANGLES

    # List of the forward vector and turn vectors
    motor_inputs = list(data.motor_inputs)
    wheel_angles = list(data.wheel_angles)

    # Combine vectors into one list
    motor_inputs.extend(wheel_angles)

    # Loop through the motor speeds and prepare the data to be sent to the arduino
    for i, value in enumerate(motor_inputs):

        # Convert the 2 joystick values into a full array of motor inputs
        if i == 0:
            for c in range(6):
                true_motor_inputs[c] = unit_range_to_controller(value)
        else:
            for c in range(4):
                c+=6
                true_motor_inputs[c] = unit_range_to_controller(value)


    # Check to see if the motor values have actually changed
    if motor_inputs != LAST_MOTOR_INPUTS:
        try:
            I2C_SERVICE(i2c_data=bytes(motor_inputs), register_id=I2CRegisterID.DriveTrain, device_address=CONTROL_ARDUINO_ADDRESS)
            return DriveTrainServiceResponse("Request Executed Successfully")
        except Exception as e:
            return DriveTrainServiceResponse(f"I2C Exception Occurred: {e}")

    # Copy the current motor speed variable to the last
    LAST_MOTOR_INPUTS = motor_inputs.copy()

def init_node():

    # Create new node to act as the controller_Service
    rospy.init_node("DriveTrainControllerNode")

    # Create the service itself
    service = rospy.Service("drive_train_controller", DriveTrainService, handler=on_service_contact)

    # Add some log information for the boot proccess
    rospy.loginfo(f"{rospy.get_name()}: waiting for the I2C_service")

    # Wait for the I2C Service to be up
    rospy.wait_for_service("I2C_Service")
    
    # Create a persistent connection to the I2C Service
    global I2C_SERVICE
    I2C_SERVICE = rospy.ServiceProxy("I2C_Service", service_class=I2C_Service, persistent=True)

    # Used to distinguish output from a launch file
    rospy.loginfo(f"{rospy.get_name()}: awaiting instruction...")

    # Setup handlers
    rospy.spin()

def unit_range_to_controller(value):
    """Convert from -1 to 1 to 0 to 127 with 64 in the middle to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

if __name__ == "__main__":
    init_node()
