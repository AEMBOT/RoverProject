#!/usr/bin/python3
"""Used to command the rover's drive train based on controller input"""

import rospy


from rover_main.msg import controllerMap
from rover_main.srv import DriveTrainService

from time import sleep
import threading

CONTROLLER_STATE = None

# Global controller deadzone
CONTROLLER_DEADZONE = 0.05

def control_topic_update(callback_data):
    global CONTROLLER_STATE
    
    # Set the data from the controller_state topic equal to a global variable that is accessed from controlling thread
    CONTROLLER_STATE = callback_data

def create_node():
    """Starts the node and subscribes the required data topics"""

    # Create a new network communication node
    rospy.init_node("TeleopControllerNode")

    # Subscribe to the controller topic to get information from
    rospy.Subscriber(name="controller_state",
                     data_class=controllerMap,
                     callback=control_topic_update,
                     queue_size=1000)
    rospy.loginfo(f"{rospy.get_name()} Started...")

    # Register subscriber events
    rospy.spin()

def control_thread():
    # Get the global version of controller state
    global CONTROLLER_STATE

    # Arrays to hold individual motor values
    motor_speeds = [0, 0, 0, 0, 0, 0]
    wheel_angles = [0, 0, 0, 0]

    # Block until the I2C service is ready and then connect so that data can be sent and received
    rospy.wait_for_service("drive_train_controller")
    drive_train_controller = rospy.ServiceProxy("drive_train_controller", service_class=DriveTrainService, persistent=True)

    # Wait for the controller values to populate and make sure that ros is still running
    while CONTROLLER_STATE == None and not rospy.is_shutdown():
        pass

    # Simple test to run both motors 
    while not rospy.is_shutdown():

        # Left Y is the forward/backward movement
        left_y = float(CONTROLLER_STATE.Joystick_LeftY)

        # Right X is the steering control
        right_x = float(CONTROLLER_STATE.Joystick_RightX)

        # TODO: FUTURE NOTICE! Change this to passing single Left Y and Right X values across and have the arduino handle interpolation of inputs, 
        # Not yet implemented as that change could break things

        # Create a slight deadzone so that you can easily stop the motors (A standard foreach loop wasn't working here)
        for i in range(len(motor_speeds)):
            motor_speeds[i] = left_y
            if(motor_speeds[i] <  0 + CONTROLLER_DEADZONE and motor_speeds[i] > 0 - CONTROLLER_DEADZONE):
                motor_speeds[i] = 0

        # Pass joystick mappings into the wheel_angles list
        for i in rage(len(wheel_angles)):
            wheel_angles[i] = right_x
            if(right_x <  0 + CONTROLLER_DEADZONE and right_x > 0 - CONTROLLER_DEADZONE):
                wheel_angles[i] = 0

        # Attempt to contact the service with the data
        try:
            rospy.loginfo(drive_train_controller(motor_speeds=motor_speeds, wheel_angles=wheel_angles))
        except rospy.ServiceException as e:
            rospy.logfatal_once(f"Service Exception Occurred: {e}")

if __name__ == "__main__":
    # Thread to handle actions taken based on controller input
    controller_thread = threading.Thread(target=control_thread)
    controller_thread.start()

    create_node()

    

