#!/usr/bin/python3
"""Used to command the rover's motors and systems based on controller input"""

import rospy
from smbus2 import SMBus

from rover_main.msg import controllerMap

from time import sleep
import threading

CONTROLLER_STATE = None

def control_topic_update(callback_data):
    global CONTROLLER_STATE
    # print(callback_data)
    CONTROLLER_STATE = callback_data

def create_node():
    """Starts the node and subscribes the required data topics"""

    # Create a new network communication node
    rospy.init_node("rover_network_comms", anonymous=True)

    # Subscribe to the controller topic to get information from
    rospy.Subscriber(name="controller_state",
                     data_class=controllerMap,
                     callback=control_topic_update,
                     queue_size=1000)
    rospy.loginfo("Started Node...")

    # Register subscriber events
    rospy.spin()

def control_thread():
    global CONTROLLER_STATE
    # Get the global version of controller state

    I2Cbus = SMBus(1)

    # Wait for the controller values to populate
    while CONTROLLER_STATE == None and not rospy.is_shutdown():
        pass
    last_val = 64
    speed = 64
    # Simple test to run both motors 
    while not rospy.is_shutdown():
        left_y = float(CONTROLLER_STATE.Joystick_LeftY)

        left_y = int(unit_range_to_controller(left_y))
        speed = left_y
        if last_val != left_y:
            if(left_y <  70 and left_y > 58):
                speed = 64

            print(speed)
            I2Cbus.write_i2c_block_data(0x08, 0x00, bytes([speed]))
        last_val = left_y
def unit_range_to_controller(value):
    """Convert from 0 - 1 to 0 - 127 to accommodate the motor controller values"""
    if value >= 0:
        if 64 + abs(round(value * 64)) > 127:
            return 127
        return (64 + abs(round(value * 64)))
    else:
        return (64 - abs(round(value * 64)))

if __name__ == "__main__":
    # Thread to handle actions taken based on controller input
    controller_thread = threading.Thread(target=control_thread)
    controller_thread.start()

    create_node()

    

